# Off-chain Workers

## Overview

Before learning how to build your own off-chain worker in Substrate, you may want to learn about what is off-chain worker, why you want to use it, and what kind of problems are best solved with off-chain worker. These topics are covered in [our Guide](https://substrate.dev/docs/en/conceptual/core/off-chain-workers).

Here, we will focus on implementing off-chain worker in Substrate. The example we will discuss is in [pallets/offchain-demo](TK).

## Life-cycle of Offchain Worker

Referring to [pallets/offchain-demo/src/lib.rs](TK), the life-cycle of an off-chain worker is kicked in after each block generation phase. Running the offchain-demo, you will see the following output:

```
...
2020-03-14 13:30:36 Starting BABE Authorship worker
2020-03-14 13:30:36 Prometheus server started at 127.0.0.1:9615
2020-03-14 13:30:41 Idle (0 peers), best: #0 (0x2658…9a5b), finalized #0 (0x2658…9a5b), ⬇ 0 ⬆ 0
2020-03-14 13:30:42 Starting consensus session on top of parent 0x26582455e63448e8dafe1e70f04d7d74d39358c6b71c306eb7013e2c54069a5b
2020-03-14 13:30:42 Prepared block for proposing at 1 [hash: 0xdc7a76fc89c45a3f318e29df06cbdb097cc3094112b204f10e1e84e0799eba88; parent_hash: 0x2658…9a5b; extrinsics (1): [0xf572…63c0]]
2020-03-14 13:30:42 Pre-sealed block for proposal at 1. Hash now 0x3558accae1325a2ae5569512b8542e90ae11b4f0de6834ba901eb03b97a680aa, previously 0xdc7a76fc89c45a3f318e29df06cbdb097cc3094112b204f10e1e84e0799eba88.
2020-03-14 13:30:42 New epoch 0 launching at block 0x3558…80aa (block slot 264027307 >= start slot 264027307).
2020-03-14 13:30:42 Next epoch starts at slot 264027407
2020-03-14 13:30:42 Imported #1 (0x3558…80aa)
2020-03-14 13:30:42 Entering off-chain workers
2020-03-14 13:30:42 off-chain send_signed: acc: 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY| number: 0
...
```

Looking back at the code, there is a `fn offchain_worker()` inside `decl_module!`. This is the entry point of the off-chain worker that is going to be executed once after each block generation. So you put all the off-chain logics here, and eventually signed and unsigned transactions will be sent from this function.

## Signed Transactions

You can have two kind of transactions from off-chain workers, signed and unsigned transaction. Signed transaction is used if the transaction has to recorded who the author of the transaction. Unsigned transaction is used more for transaction generated by the internal system. They are setup differently.

### Setup

For signed transaction, referring to [pallets/offchain-demo/src/lib.rs](TK), your configurable trait will set a new associated type.

src: [pallets/offchain-demo/src/lib.rs](TK)

```rust
pub trait Trait: system::Trait {
	//...snip...
	type SubmitSignedTransaction:
	offchain::SubmitSignedTransaction<Self, <Self as Trait>::Call>;

}
```

Now the runtime at [runtimes/super-runtime/src/lib.rs](TK), when implementing this trait for the runtime, you need to define this type. Looking at [the rustdoc of SubmitTransaction](https://substrate.dev/rustdocs/v2.0.0-alpha.3/frame_system/offchain/trait.SubmitSignedTransaction.html), the first thing you will notice is we define another sub-module here:

```rust
pub const KEY_TYPE: KeyTypeId = KeyTypeId(*b"demo");

pub mod crypto {
	use crate::KEY_TYPE;
	use sp_runtime::app_crypto::{app_crypto, sr25519};
	app_crypto!(sr25519, KEY_TYPE);
}
```

This is the application key to be used to sign the transaction coming from this pallet.

The second thing you will notice is that we should use the `TransactionSubmitter` type implementation as follows.

src: [runtimes/super-runtime/src/lib.rs](TK)

```rust
type SubmitTransaction = system::offchain::TransactionSubmitter<
	offchain_demo::crypto::Public,
	Runtime,
	UncheckedExtrinsic
>;

impl offchain_demo::Trait for Runtime {
	type Call = Call;
	type Event = Event;
	type SubmitSignedTransaction = SubmitTransaction;
	//...snip...
}
```

Now if you build the `kitchen-node`, the trait bound for ``Runtime: frame_system::offchain::CreateTransaction` is not satisfied. When using `SubmitSignedTransaction`, we also need to have our Runtime implement [`CreateTransaction` trait](https://substrate.dev/rustdocs/v2.0.0-alpha.3/frame_system/offchain/trait.CreateTransaction.html). We add the following piece of code to define how a signed transaction is being called.

src: [runtimes/super-runtime/src/lib.rs](TK)

```rust
impl system::offchain::CreateTransaction<Runtime, UncheckedExtrinsic> for Runtime {
	type Public = <Signature as Verify>::Signer;
	type Signature = Signature;

	fn create_transaction<TSigner: system::offchain::Signer<Self::Public, Self::Signature>> (
		call: Call,
		public: Self::Public,
		account: AccountId,
		index: Index,
	) -> Option<(Call, <UncheckedExtrinsic as sp_runtime::traits::Extrinsic>::SignaturePayload)> {
		// take the biggest period possible.
		let period = BlockHashCount::get()
			.checked_next_power_of_two()
			.map(|c| c / 2)
			.unwrap_or(2) as u64;
		let current_block = System::block_number()
			.saturated_into::<u64>().saturating_sub(1);
		let tip = 0;
		let extra: SignedExtra = (
			system::CheckVersion::<Runtime>::new(),
			system::CheckGenesis::<Runtime>::new(),
			system::CheckEra::<Runtime>::from(generic::Era::mortal(period, current_block)),
			system::CheckNonce::<Runtime>::from(index),
			system::CheckWeight::<Runtime>::new(),
			transaction_payment::ChargeTransactionPayment::<Runtime>::from(tip),
		);

		let raw_payload = SignedPayload::new(call, extra).map_err(|e| {
			debug::native::warn!("SignedPayload error: {:?}", e);
		}).ok()?;

		let signature = TSigner::sign(public, &raw_payload)?;
		let address = account;
		let (call, extra, _) = raw_payload.deconstruct();
		Some((call, (address, signature, extra)))
	}
}

// ...snip...
```

The `SignedExtra` is defined below

```rust
/// The SignedExtension to the basic transaction logic.
pub type SignedExtra = (
	system::CheckVersion<Runtime>,
	system::CheckGenesis<Runtime>,
	system::CheckEra<Runtime>,
	system::CheckNonce<Runtime>,
	system::CheckWeight<Runtime>,
	transaction_payment::ChargeTransactionPayment<Runtime>,
);
```

Basically, we sign the `call` and `extra` (also called signed extension). Finally the actual call, sender, the data, and its signature are sent on-chain to be run.

### Sending Signed Transactions

A signed transaction is sent from:

src: [TK]

```rust
fn send_signed(block_number: T::BlockNumber) -> Result<(), Error<T>> {
	use system::offchain::SubmitSignedTransaction;
	//..snip

	let submission: u64 = block_number.try_into().ok().unwrap() as u64;
	let call = Call::submit_number_signed(submission);

	// Using `SubmitSignedTransaction` associated type we create and submit a transaction
	// representing the call, we've just created.
	// Submit signed will return a vector of results for all accounts that were found in the
	// local keystore with expected `KEY_TYPE`.
	let results = T::SubmitSignedTransaction::submit_signed(call);
	for (acc, res) in &results {
		match res {
			Ok(()) => { debug::native::info!("off-chain send_signed: acc: {}| number: {}", acc, submission); },
			Err(e) => {
				debug::native::error!("[{:?}] Failed to submit signed tx: {:?}", acc, e);
				return Err(<Error<T>>::SendSignedError);
			}
		};
	}
	Ok(())
}
```

We have a function reference to `Call::submit_number_signed(submission)`. This is the function we are going to submit back to on-chain, and then pass it as `T::SubmitSignedTransaction::submit_signed(call)`.

You will notice that we run a for loop in the results, which implies that this call may make multiple transactions and return multiple results. This is true because this call actually sign and send the transaction with all the locally found accounts for the given application crypto (what we defined early in `pub mod crypto {...}`). But we only have one key right now for the app crypto, so only one signed transaction is made.

If you want to dig deeper to see where we add the local account, it is actually added in the node runtime.

src: [nodes/kitchen-node/src/service.rs](TK)

```rust
pub fn new_full(config: Configuration<GenesisConfig>)
	-> Result<impl AbstractService, ServiceError>
{
	// ...snip
	let dev_seed = config.dev_key_seed.clone();

	// ...snip
	// Initialize seed for signing transaction using off-chain workers
	if let Some(seed) = dev_seed {
		service
			.keystore()
			.write()
			.insert_ephemeral_from_seed_by_type::<runtime::offchain_demo::crypto::Pair>(
				&seed,
				runtime::offchain_demo::KEY_TYPE,
			)
			.expect("Dev Seed should always succeed.");
	}

	// ...snip
}
```

## Unsigned Transactions

### Setup

For unsigned transactions, you would see we have the equivalent setup in the pallet configrable trait.

src: [pallets/offchain-demo/src/lib.rs](TK)

```rust
pub trait Trait: system::Trait {
	/// The overarching dispatch call type.
	type Call: From<Call<Self>>;
	/// The overarching event type.
	type Event: From<Event<Self>> + Into<<Self as system::Trait>::Event>;
	/// The type to submit unsigned transactions.
	type SubmitUnsignedTransaction:
		offchain::SubmitUnsignedTransaction<Self, <Self as Trait>::Call>;
	// ...snip
}
```

By default, unsigned transactions are rejected by Substrate runtime unless they are explcitly allowed. So we need to write additional logics to allow unsigned transactions for that particular dispatched function, as follows:

```rust
impl<T: Trait> support::unsigned::ValidateUnsigned for Module<T> {
	type Call = Call<T>;

	fn validate_unsigned(call: &Self::Call) -> TransactionValidity {
		if let Call::submit_number_unsigned(block_num, number) = call {
			debug::native::info!("off-chain send_unsigned: block_num: {}| number: {}", block_num, number);

			Ok(ValidTransaction {
				priority: 1 << 20,
				requires: vec![],
				provides: vec![codec::Encode::encode(&(KEY_TYPE.0, block_num))],
				longevity: 3,
				propagate: false,
			})
		} else {
			InvalidTransaction::Call.into()
		}
	}
}
```

We implement `ValidateUnsigned`, and the allowance logic is added in the `fn validate_unsigned()` function. We check if the call is to `Call::submit_number_unsigned`, it returns an `Ok()`. Otherwise, `InvalidTransaction::Call`.

The `ValidTransaction` object has a few fields touches on concept we have not talked about before.

- `priority`: it determines the ordering of two transactions given their dependencies are satisfied.
- `requires`: list of other tags that this transaction depends on.
- `provides`: list of tags provided by this transaction. Successfully importing the transaction will enable other transactions that depend on those tags to be included as well. Provided and required tags allow Substrate to build a dependency graph of transactions and import them in the right order.
- `longevity`: Transaction longevity, which describes minimum number of blocks the validity is correct. After this period transaction should be removed from the pool or revalidated.
- `propagate`: A flag indicating if the transaction should be propagated to other peers. By setting false the transaction will still be considered for including in blocks that are authored on the current node, but will never be sent to other peers.

Third, we specify the associated type of `SubmitUnsignedTransaction` in runtime setup.

src: [runtimes/super-runtime/src/lib.rs](TK)

```rust
type SubmitTransaction = system::offchain::TransactionSubmitter<
	offchain_demo::crypto::Public,
	Runtime,
	UncheckedExtrinsic
>;

impl offchain_demo::Trait for Runtime {
	//...snip
	type SubmitUnsignedTransaction = SubmitTransaction;
}
```

Finally, to tell the runtime you have your own `ValidateUnsigned` logic, you also need to pass this as a parameter when contructing the runtime.

src: [runtimes/super-runtime/src/lib.rs](TK)

```rust
construct_runtime!(
	pub enum Runtime where
		Block = Block,
		NodeBlock = opaque::Block,
		UncheckedExtrinsic = UncheckedExtrinsic
	{
		//...snip
		OffchainDemo: offchain_demo::{Module, Call, Storage, Event<T>, ValidateUnsigned},
	}
);
```

### Sending Unsigned Transactions

You can then make an unsigned transaction from offchain worker with `T::SubmitUnsignedTransaction::submit_unsigned()`, as shown in the code.

src: [pallets/offchain-demo/src/lib.rs](TK)

```rust
fn send_unsigned(block_number: T::BlockNumber) -> Result<(), Error<T>> {
	use system::offchain::SubmitUnsignedTransaction;

	let submission: u64 = block_number.try_into().ok().unwrap() as u64;
	// the `block_number` param should be unique within each block generation phase
	let call = Call::submit_number_unsigned(block_number, submission);

	T::SubmitUnsignedTransaction::submit_unsigned(call).map_err(|e| {
		debug::native::error!("Failed to submit unsigned tx: {:?}", e);
		<Error<T>>::SendUnsignedError
	})
}
```

You still prepare a function reference with its parameters, as needed for signed transaction, and then call `T::SubmitUnsignedTransaction::submit_unsigned()`.

## Off-chain HTTP Requests

[TODO]

## JSON Parsing

[TODO]

## Testing

Now for writing test cases to test off-chain worker, refer to our [testing section](TK).
